import{K as r,u as f,b as c,c as u}from"./ConfigManager-f1a6a1ab.js";import{u as E,S as m,E as y,D as U,a as Z,A as b,c as Q,M as j,b as X,d as Y,e as z,f as ee}from"./SearcherAll-7598ce4f.js";class te{static async verify(e){const t=e.split(".");if(t.length!==3)throw new Error("Invalid JWT");const s=window.kee.utils.base64urlDecode(t[1]);let n;try{if(n=JSON.parse(s),n.aud!=="client")return{audience:n.aud}}catch{throw new Error("Invalid claim")}const o=new TextEncoder().encode(t[0]+"."+t[1]).buffer;let a;switch(n.iss){case"idProd":a={kty:"EC",crv:"P-256",x:"O6bWMktjPnOtZAkmz9NzMTO9O2VzuECTa9Jj5g90QSA",y:"aIE-8dLpJIoAnLIzH1XDCPxK_asKtIC_fVlSLJyGpcg",ext:!0};break;case"idBeta":a={kty:"EC",crv:"P-256",x:"CinRkFHv6IGNcd52YlzD3BF_WruIMs-6Nn5oI7QmgjU",y:"pJ66MRPoCC2MUBFdYyRqGPfw3pZEnPGtHVhvspLTVDA",ext:!0};break;case"idDev":a={kty:"EC",crv:"P-256",x:"mk8--wDgrkPyHttzjQH6jxmjfZS9MaHQ5Qzj53OnNLo",y:"XAFQCFwKL7qrV27vI1tug3X2v50grAk_ioieHRe8h18",ext:!0};break;default:throw new Error("Unknown JWT issuer so cannot verify")}const l=await window.crypto.subtle.importKey("jwk",a,{name:"ECDSA",namedCurve:"P-256"},!1,["verify"]);if(!await window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},l,window.kee.utils.base64urltoByteArray(t[2]),o))throw new Error("JWT signature did not verify");return{claim:n,audience:n.aud}}}class se{constructor(){this._features=[]}get features(){return this._features}get featureExpiry(){return this._featureExpiry}get tokens(){return this._tokens}async parseJWTs(e){if(this._tokens={},!e||!e.client)return;const t=e.client;try{const{audience:s,claim:n}=await te.verify(t);s==="client"&&n!==void 0&&n.exp>Date.now()-3600*24*30*1e3&&(this._features=n.features,this._featureExpiry=n.featureExpiry,this._tokens.client=t)}catch(s){r.error("Token error: "+s)}}}class ne{async processNewTokens(e){await this.account.parseJWTs(e),this.notify()}notify(){this.listeners.forEach(e=>{e()})}addListener(e){this.listeners.push(e)}get features(){return this.account.features}constructor(){this.account=new se,this.listeners=[]}featuresValidSecondsAgo(e){return this.account.featureExpiry>Date.now()-e*1e3}get featureEnabledMultiSessionTypes(){return this.account.features.indexOf("multiSession")>=0&&this.featuresValidSecondsAgo(3600*24*7)}get featureEnabledSyncSettings(){return this.account.features.indexOf("syncSettings")>=0&&this.featuresValidSecondsAgo(3600*24*14)}get featureEnabledFormAccuracy(){return this.account.features.indexOf("formAccuracy")>=0&&this.featuresValidSecondsAgo(3600*24*3)}}var k=(i=>(i.Teardown="teardown",i.Jsonrpc="jsonrpc",i.Ping="ping",i.Error="error",i.Reconnect="reconnect",i.AckInit="ackinit",i.ShowGenerator="showgenerator",i))(k||{});class re{constructor(e,t){this.sessionId=e,this.messageToWebPage=t}}class K{constructor(e,t,s){this.onOpen=e,this.onClose=t,this.onMessage=s,this.eventActivityTimeout=3e4,this._features=[],this.eventActivityTimer=null,this.callbacks={}}isActive(){return!!this.latestSession}features(){return this.latestSession?this._features:[]}registerCallback(e,t){this.callbacks[e]=t}invokeCallback(e,t){this.callbacks[e]!=null&&this.callbacks[e](t)}unregisterCallback(e){delete this.callbacks[e]}startSession(e,t,s){if(r.debug("Event session starting"),!e)return{protocol:k.Error,error:{code:"SESSION_NOT_SUPPLIED",messageParams:["you must supply a sessionId"]}};if(this.latestSession&&this.latestSession.sessionId)if(e===this.latestSession.sessionId){r.warn("Duplicate session start request received");return}else r.warn("Session start request received while session still active. Destroying old session."),this.closeSession();if(this.latestSession=new re(e,s),this.onOpen(t),this.isActive())return this._features=t,clearTimeout(this.eventActivityTimer),this.eventActivityTimer=window.setTimeout(()=>{this.closeSession()},this.eventActivityTimeout),{protocol:k.AckInit}}messageReciever(e){if(r.debug("message received"),!e.sessionId){this.sendErrorMessage({code:"SESSION_NOT_SUPPLIED",messageParams:["you must supply a sessionId"]});return}if(e.protocol===k.Teardown){this.closeSession();return}if(!this.latestSession)return{protocol:k.Error,error:{code:"SESSION_MISSING",messageParams:["Session not initialised or has timed out"]}};if(e.sessionId!=this.latestSession.sessionId)return this.sendErrorMessage({code:"SESSION_MISMATCH",messageParams:["Already attached to a session (maybe in a different tab). Reinitialisation required."]}),{protocol:k.Error,error:{code:"SESSION_MISMATCH",messageParams:["Already attached to a session (maybe in a different tab). Reinitialisation required."]}};clearTimeout(this.eventActivityTimer),this.eventActivityTimer=window.setTimeout(()=>{this.closeSession()},this.eventActivityTimeout),e.protocol!==k.Ping&&e.protocol===k.Jsonrpc&&(e.encryptionNotRequired=!0,this.onMessage(e))}sendErrorMessage(e){if(!this.latestSession)throw r.error("Server session went away."),new Error("Server session went away.");this.latestSession.messageToWebPage({error:e,protocol:k.Error})}sendMessage(e){if(!this.latestSession)throw r.error("Server session went away."),new Error("Server session went away.");this.latestSession.messageToWebPage(e)}closeSession(){r.debug("Closing event session"),clearTimeout(this.eventActivityTimer),this.latestSession=null,this._features=[],this.callbacks={},window.kee.configSyncManager.reset(),this.onClose()}}class ie{constructor(){const e="d4c7f8a2b32c11b8fba9581ec4ba4f1b04215642ef7355e37c0fc0443ef756ea2c6b8eeb755a1c723027663caa265ef785b8ff6a9b35227a52d86633dbdfca43";for(this.N=BigInteger.parse(e,16),this.g=new BigInteger("2"),this.k=BigInteger.parse("b7867f1299da8cc24ab93e08986ebc4d6a478ad0",16),this.a=f.BigIntFromRandom(32),this.A=this.g.modPow(this.a,this.N);this.A.remainder(this.N)==0;)this.a=f.BigIntFromRandom(32),this.A=this.g.modPow(this.a,this.N);this.Astr=this.A.toString(16),this.S=null,this.K=null,this.M=null,this.M2=null,this.authenticated=!1,this.I=null,this.p=null}setup(e){this.I=e}receiveSalts(e,t){return this.calculations(e,t,this.p)}calculations(e,t,s){const n=BigInteger.parse(t,16),o=t;return Promise.all([f.hash(this.Astr+o),f.hash(e+s)]).then(a=>{const l=BigInteger.parse(a[0],16),h=BigInteger.parse(a[1],16),p=this.k.multiply(this.g.modPow(h,this.N)),w=this.a.add(l.multiply(h));this.S=n.subtract(p).modPow(w,this.N);const S=this.A.toString(16)+n.toString(16)+this.S.toString(16);return f.hash(S)}).then(a=>(this.M=a,f.hash(this.A.toString(16)+this.M+this.S.toString(16)))).then(a=>{this.M2=a})}confirmAuthentication(e){e.toLowerCase()==this.M2.toLowerCase()?(this.authenticated=!0,this.success()):r.error("Server key does not match")}success(){}key(){return this.K==null?this.authenticated?f.hash(this.S.toString(16)).then(e=>(this.K=e.toLowerCase(),this.K)):(r.error("User has not been authenticated."),Promise.resolve(null)):Promise.resolve(this.K)}}class N{constructor(e,t,s,n,o){this._features=[],this.onOpening=e,this.onOpen=t,this.onClose=s,this.onMessage=n,this.isKPRPCAuthorised=o,this.reconnectionAttemptFrequency=2e3,this.connectLock=!1,this.wasEverOpen=!1,this.webSocketHost="127.0.0.1",this.webSocket=null,this._reconnectTimer=null,this.connectionProhibitedUntil=new Date(0),this.speculativeWebSocketAttemptProhibitedUntil=new Date(0),this.callbacks={}}isActive(){return this.webSocket!==void 0&&this.webSocket!==null&&this.webSocket.readyState==WebSocket.OPEN&&this.isKPRPCAuthorised()}features(){return this.isActive()?this._features:[]}setClaimedFeatures(e){this._features=e}registerCallback(e,t){this.callbacks[e]=t}invokeCallback(e,t){this.callbacks[e]!=null&&this.callbacks[e](t)}unregisterCallback(e){delete this.callbacks[e]}startup(){this.pendingPortChange=null,c.runtime.onMessage.addListener(e=>{e.action==="KPRPC_Port_Change"&&(this.pendingPortChange!=null&&clearTimeout(this.pendingPortChange),this.pendingPortChange=window.setTimeout(()=>{this.configureConnectionURIs(),this.webSocket!==void 0&&this.webSocket!==null&&this.webSocket.readyState!=WebSocket.CLOSED&&this.webSocket.close()},1e3))}),this.configureConnectionURIs(),this._reconnectTimer=window.setInterval(this.attemptConnection.bind(this),this.reconnectionAttemptFrequency),r.debug("Created an HTTP/ws reconnection timer.")}configureConnectionURIs(){this.webSocketPort=u.current.KeePassRPCWebSocketPort,(this.webSocketPort<=0||this.webSocketPort>65535||this.webSocketPort==19455)&&(u.current.KeePassRPCWebSocketPort=12546,u.save(),this.webSocketPort=12546),this.webSocketURI="ws://"+this.webSocketHost+":"+this.webSocketPort,this.httpChannelURI="http://"+this.webSocketHost+":"+this.webSocketPort}tryToconnectToWebsocket(){r.debug("Attempting to connect to RPC server webSocket.");const e=this.connect();e=="alive"&&r.debug("Connection already established."),e=="locked"&&r.debug("Connection attempt already underway.")}httpConnectionAttemptCallback(){this._webSocketTimer=window.setTimeout(this.tryToconnectToWebsocket.bind(this),100)}connect(){const e=this;if(this.connectLock)return"locked";if(this.webSocket!==void 0&&this.webSocket!==null&&this.webSocket.readyState==WebSocket.OPEN)return"alive";if(this.connectionProhibitedUntil.getTime()>new Date().getTime()||!this.onOpening())return"locked";r.debug("Trying to open a webSocket connection"),this.connectLock=!0,this.wasEverOpen=!1;try{this.webSocket=new WebSocket(this.webSocketURI)}catch{this.connectLock=!1;return}this.webSocket.onopen=function(){r.info("Websocket connection opened"),e.connectLock=!1,e.wasEverOpen=!0,e.onOpen()},this.webSocket.onmessage=function(t){r.debug("received message from web socket");const s=JSON.parse(t.data);if(!s){r.error("received bad message from web socket. Can't parse from JSON.");return}e.onMessage(s)},this.webSocket.onerror=function(){e.wasEverOpen&&r.debug("Websocket connection error"),e.connectLock=!1},this.webSocket.onclose=function(){e.wasEverOpen&&(e.wasEverOpen=!1,e.onCloseSession(),r.debug("Websocket connection closed"))}}closeSession(){this.webSocket&&this.webSocket.close()}onCloseSession(){this.callbacks={},this.onClose()}attemptConnection(){const e=this;if(!e.connectLock&&!(e.webSocket!==void 0&&e.webSocket!==null&&e.webSocket.readyState!=WebSocket.CLOSED)&&!(e.connectionProhibitedUntil.getTime()>new Date().getTime()))if(new Date().getTime()>e.speculativeWebSocketAttemptProhibitedUntil.getTime())r.debug("Speculatively trying to open a webSocket connection"),e.speculativeWebSocketAttemptProhibitedUntil=new Date,e.speculativeWebSocketAttemptProhibitedUntil.setTime(e.speculativeWebSocketAttemptProhibitedUntil.getTime()+73e3),e.httpConnectionAttemptCallback();else{const t=new XMLHttpRequest;t.open("GET",e.httpChannelURI,!0),t.timeout=750,t.onerror=function(){r.debug("HTTP connection did not timeout. We will now attempt a web socket connection."),e.httpConnectionAttemptCallback()},t.ontimeout=function(){r.debug("HTTP connection timed out. Will not attempt web socket connection.")},t.onabort=function(){r.warn("HTTP connection aborted. Will not attempt web socket connection.")},t.send()}}sendMessage(e){try{this.webSocket.send(e)}catch(t){r.error("Failed to send a websocket message. Exception details: "+t+", stack: "+t.stack)}}}class O{}O.offered=["KPRPC_FEATURE_VERSION_1_6","KPRPC_FEATURE_WARN_USER_WHEN_FEATURE_MISSING","KPRPC_FEATURE_BROWSER_HOSTED","BROWSER_SETTINGS_SYNC"];O.required=["KPRPC_FEATURE_VERSION_1_6","KPRPC_GENERAL_CLIENTS","KPRPC_SECURITY_FIX_20200729"];class oe{constructor(e,t,s,n,o){this.name=e,this.buttons=t,this.id=s,this.messages=n,this.priority=o}}class ae{constructor(e){this.responsesRequired=e,this.responses=[],this.pendingResponses=new Promise(t=>{this.resolve=t})}onResponse(e,t,s){this.responses.push({sessionType:e,resultWrapper:t,features:s}),this.responses.length===this.responsesRequired&&this.resolve(this.responses)}}class ce{constructor(){this.nextRequestId=1,this.clientVersion=[2,0,0],this.srpClientInternals=null,this.secretKey=null,this.eventSessionManager=new K(e=>this.setupEventSession(e),()=>this.onEventSessionClosed(),e=>this.receive(e,this.eventSessionManager)),this.websocketSessionManager=new N(()=>window.kee.accountManager.featureEnabledMultiSessionTypes||!this.eventSessionManager.isActive(),()=>this.setupWebsocketSession(),()=>this.onWebsocketSessionClosed(),e=>this.receive(e,this.websocketSessionManager),()=>!!this.secretKey),this.store=E()}startWebsocketSessionManager(){this.websocketSessionManager.startup()}startEventSession(e,t,s){return this.eventSessionManager.startSession(e,t,s)}eventSessionMessageFromPage(e){return this.eventSessionManager.messageReciever(e)}getSessionManagerByType(e){return e===m.Event?this.eventSessionManager:this.websocketSessionManager}getPrimarySessionManager(){return this.eventSessionManager.isActive()?this.eventSessionManager:this.websocketSessionManager.isActive()?this.websocketSessionManager:null}getManagersForActiveSessions(){const e=[];return this.eventSessionManager.isActive()&&e.push(this.eventSessionManager),this.websocketSessionManager.isActive()&&e.push(this.websocketSessionManager),e}request(e,t,s){const n=++this.nextRequestId,o=JSON.stringify({jsonrpc:"2.0",params:s,method:t,id:n});r.debug("Sending a JSON-RPC request");const a=new ae(e.length);for(const l of e)try{l instanceof K?(this.eventSessionManager.registerCallback(n,h=>a.onResponse(m.Event,h,l.features())),this.sendJSONRPCUnencrypted(o)):typeof crypto<"u"&&typeof crypto.subtle<"u"&&(this.websocketSessionManager.registerCallback(n,h=>a.onResponse(m.Websocket,h,l.features())),this.encrypt(o,this.sendJSONRPCEncrypted))}catch(h){r.warn("JSON-RPC request could not be sent. Expect an async error soon. Exception: "+h.message+":"+h.stack),window.setTimeout(()=>{this.processJSONRPCresponse({id:n,error:{message:"Send failure. Maybe the server went away?"},message:"error"},l)},50)}return a.pendingResponses}evalJson(e,t){let s=JSON.stringify(t);r.debug("Evaluating a JSON-RPC object we just received"),s&&(s=s.match(/\s*\[(.*)\]\s*/)[1]),(e=="KPRPCListener"||e=="callBackToKeeFoxJS")&&this.KPRPCListener(s)}KPRPCListener(e){window.setTimeout(function(){window.kee.KPRPCListener(e)},5)}sendJSONRPCEncrypted(e){const t={protocol:k.Jsonrpc,srp:null,key:null,error:null,jsonrpc:e,version:f.versionAsInt(this.clientVersion)};this.websocketSessionManager.sendMessage(JSON.stringify(t))}sendJSONRPCUnencrypted(e){const t={protocol:k.Jsonrpc,srp:null,key:null,error:null,jsonrpc:e,encryptionNotRequired:!0,version:f.versionAsInt(this.clientVersion)};this.eventSessionManager.sendMessage(t)}onWebsocketSessionClosed(){this.srpClientInternals=null,this.secretKey=null,this.eventSessionManager.isActive()?window.kee._refreshKPDB():(window.kee._pauseKee(),window.kee.inviteKeeVaultConnection())}onEventSessionClosed(){this.websocketSessionManager.isActive()?window.kee._refreshKPDB():window.kee._pauseKee()}receive(e,t){if(e!=null&&!(e.protocol===void 0||e.protocol===null))switch(e.protocol){case"setup":this.receiveSetup(e);break;case"jsonrpc":this.receiveJSONRPC(e);break;case"error":if(e.error){const s=[];e.error.messageParams&&e.error.messageParams.length>=1&&(s[0]=e.error.messageParams[0]),e.error.code=="VERSION_CLIENT_TOO_LOW"?(r.error($STR("conn_setup_client_features_missing")+" Extra info: "+s),this.store.updateLatestConnectionError("VERSION_CLIENT_TOO_LOW"),this.showConnectionMessage($STR("conn_setup_client_features_missing"))):e.error.code=="UNRECOGNISED_PROTOCOL"?(r.error($STR("conn_unknown_protocol")+" "+$STRF("further_info_may_follow",s)),this.store.updateLatestConnectionError("UNRECOGNISED_PROTOCOL")):e.error.code=="INVALID_MESSAGE"?(r.error($STR("conn_invalid_message")+" "+$STRF("further_info_may_follow",s)),this.store.updateLatestConnectionError("INVALID_MESSAGE")):e.error.code=="AUTH_RESTART"?(r.error($STR("conn_setup_restart")+" "+$STRF("further_info_may_follow",s)),this.store.updateLatestConnectionError("AUTH_RESTART"),this.removeStoredKey(this.getUsername(this.getSecurityLevel())),this.showConnectionMessage($STR("conn_setup_restart")+" "+$STR("conn_setup_retype_password"))):(r.error($STR("conn_unknown_error")+" "+$STRF("further_info_may_follow",s)),this.store.updateLatestConnectionError("UNKNOWN_JSONRPC"),this.showConnectionMessage($STR("conn_unknown_error")+" "+$STRF("further_info_may_follow",["See Kee log"])))}t.closeSession();break;default:return}}receiveSetup(e){if(e.protocol=="setup"){if(e.error){const t=[];switch(e.error.messageParams&&e.error.messageParams.length>=1&&(t[0]=e.error.messageParams[0]),e.error.code){case"AUTH_CLIENT_SECURITY_LEVEL_TOO_LOW":{r.warn($STR("conn_setup_client_sl_low")),this.store.updateLatestConnectionError("AUTH_CLIENT_SECURITY_LEVEL_TOO_LOW");const s={label:$STR("conn_setup_client_sl_low_resolution"),action:"enableHighSecurityKPRPCConnection"};this.showConnectionMessage($STR("conn_setup_client_sl_low"),[s]);break}case"AUTH_FAILED":{r.warn($STR("conn_setup_failed")+" "+$STRF("further_info_may_follow",t)),this.store.updateLatestConnectionError("AUTH_FAILED"),this.showConnectionMessage($STR("conn_setup_failed")+" "+$STR("conn_setup_retype_password")),this.removeStoredKey(this.getUsername(this.getSecurityLevel()));break}case"AUTH_RESTART":{r.warn($STR("conn_setup_restart")+" "+$STRF("further_info_may_follow",t)),this.store.updateLatestConnectionError("AUTH_RESTART"),this.removeStoredKey(this.getUsername(this.getSecurityLevel())),this.showConnectionMessage($STR("conn_setup_restart")+" "+$STR("conn_setup_retype_password"));break}case"AUTH_EXPIRED":{r.warn($STRF("conn_setup_expired",t)),this.store.updateLatestConnectionError("AUTH_EXPIRED"),this.removeStoredKey(this.getUsername(this.getSecurityLevel())),this.showConnectionMessage($STR("conn_setup_expired")+" "+$STR("conn_setup_retype_password"));break}case"AUTH_INVALID_PARAM":{r.error($STRF("conn_setup_invalid_param",t)),this.store.updateLatestConnectionError("AUTH_INVALID_PARAM");break}case"AUTH_MISSING_PARAM":{r.error($STRF("conn_setup_missing_param",t)),this.store.updateLatestConnectionError("AUTH_MISSING_PARAM");break}default:{r.error($STR("conn_unknown_error")+" "+$STRF("further_info_may_follow",t)),this.store.updateLatestConnectionError("UNKNOWN_SETUP"),this.showConnectionMessage($STR("conn_unknown_error")+" "+$STRF("further_info_may_follow",["See Kee log"]));break}}this.websocketSessionManager.closeSession();return}if(e.srp&&e.srp.stage==="identifyToClient"||e.key&&e.key.sc){if(!this.serverHasRequiredFeatures(e.features)){r.error($STRF("conn_setup_server_features_missing",["https://www.kee.pm/upgrade-kprpc"])),this.store.updateLatestConnectionError("VERSION_CLIENT_TOO_HIGH");const t={label:$STR("upgrade_kee"),action:"loadUrlUpgradeKee"};this.showConnectionMessage($STRF("conn_setup_server_features_missing",["https://www.kee.pm/upgrade-kprpc"]),[t]),this.websocketSessionManager.closeSession();return}this.websocketSessionManager.setClaimedFeatures(e.features)}if(e.key!==void 0&&e.key!==null&&(this.checkServerSecurityLevel(e.key.securityLevel)?e.key.sc?this.keyChallengeResponse1(e):e.key.sr&&this.keyChallengeResponse2(e):(r.warn($STRF("conn_setup_server_sl_low",[this.getSecurityLevelServerMinimum().toString()])),this.store.updateLatestConnectionError("AUTH_SERVER_SECURITY_LEVEL_TOO_LOW"),this.sendWebsocketsError("AUTH_SERVER_SECURITY_LEVEL_TOO_LOW",[this.getSecurityLevelServerMinimum()]),this.showConnectionMessage($STRF("conn_setup_server_sl_low",[this.getSecurityLevelServerMinimum().toString()])))),e.srp!==void 0&&e.srp!==null)if(this.checkServerSecurityLevel(e.srp.securityLevel))switch(e.srp.stage){case"identifyToClient":this.getSideChannelPassword(e);break;case"proofToClient":this.proofToClient(e);break;default:return}else r.warn($STRF("conn_setup_server_sl_low",[this.getSecurityLevelServerMinimum().toString()])),this.store.updateLatestConnectionError("AUTH_SERVER_SECURITY_LEVEL_TOO_LOW"),this.sendWebsocketsError("AUTH_SERVER_SECURITY_LEVEL_TOO_LOW",[this.getSecurityLevelServerMinimum()]),this.showConnectionMessage($STRF("conn_setup_server_sl_low",[this.getSecurityLevelServerMinimum().toString()]))}}sendWebsocketsError(e,t){const s={protocol:"setup",srp:null,key:null,error:{code:e,params:t},version:f.versionAsInt(this.clientVersion)};this.websocketSessionManager.sendMessage(JSON.stringify(s))}serverHasRequiredFeatures(e){return!(!e||!O.required.every(function(t){return e.indexOf(t)!==-1}))}checkServerSecurityLevel(e){return e>=this.getSecurityLevelServerMinimum()}keyChallengeResponse1(e){this.keyChallengeParams={sc:e.key.sc,cc:f.BigIntFromRandom(32).toString(16).toLowerCase()},f.hash("1"+this.getStoredKey()+this.keyChallengeParams.sc+this.keyChallengeParams.cc).then(t=>{const s=t.toLowerCase(),n={protocol:"setup",key:{cc:this.keyChallengeParams.cc,cr:s,securityLevel:this.getSecurityLevel()},version:f.versionAsInt(this.clientVersion)};this.websocketSessionManager.sendMessage(JSON.stringify(n))})}keyChallengeResponse2(e){f.hash("0"+this.getStoredKey()+this.keyChallengeParams.sc+this.keyChallengeParams.cc).then(t=>{if(t.toLowerCase()!=e.key.sr){r.warn($STR("conn_setup_failed")),this.store.updateLatestConnectionError("CHALLENGE_RESPONSE_MISMATCH"),this.showConnectionMessage($STR("conn_setup_failed")+" "+$STR("conn_setup_retype_password")),this.removeStoredKey(this.getUsername(this.getSecurityLevel())),this.websocketSessionManager.closeSession();return}else this.secretKey=this.getStoredKey(),window.setTimeout(this.onConnectStartup,50,"CR",this.onConnectStartup)})}async getSideChannelPassword(e){const t=e.srp.s,s=e.srp.B,n=this,o=await c.tabs.query({url:["https://keevault.pm/*","https://app-beta.kee.pm/*","https://app-dev.kee.pm/*"]});function a(p){p.action==="SRP_ok"&&(n.identifyToClient(p.password,t,s),c.runtime.onMessage.removeListener(a))}c.runtime.onMessage.addListener(a);const l={url:"/dialogs/SRP.html",active:!(o&&o[0]&&o[0].active)},h=await c.tabs.create(l);c.windows.update(h.windowId,{focused:!0,drawAttention:!0})}identifyToClient(e,t,s){this.srpClientInternals.p=e,this.srpClientInternals.receiveSalts(t,s).then(()=>{const n={protocol:"setup",srp:{stage:"proofToServer",M:this.srpClientInternals.M,securityLevel:this.getSecurityLevel()},version:f.versionAsInt(this.clientVersion)};this.websocketSessionManager.sendMessage(JSON.stringify(n))})}proofToClient(e){if(this.srpClientInternals.confirmAuthentication(e.srp.M2),this.srpClientInternals.authenticated)this.srpClientInternals.key().then(t=>{t&&(this.secretKey=t,this.setStoredKey(this.srpClientInternals.I,this.getSecurityLevel(),t),window.setTimeout(this.onConnectStartup,50,"SRP"))});else{r.warn($STR("conn_setup_failed")),this.store.updateLatestConnectionError("SRP_AUTH_FAILURE"),this.showConnectionMessage($STR("conn_setup_failed")+" "+$STR("conn_setup_retype_password")),this.removeStoredKey(this.getUsername(this.getSecurityLevel())),this.websocketSessionManager.closeSession();return}}onConnectStartup(){window.kee.removeUserNotifications(e=>e.name!="kee-connection-message"),this.store.updateLatestConnectionError(""),window.kee._refreshKPDB()}receiveJSONRPC(e){if(e.encryptionNotRequired)this.receiveJSONRPCUnencrypted(e.jsonrpc);else{if(typeof crypto<"u"&&typeof crypto.subtle<"u"){this.decrypt(e.jsonrpc,this.receiveJSONRPCDecrypted);return}throw new Error("Webcrypto required but disabled or broken")}}receiveJSONRPCUnencrypted(e){if(e===null)return;const t=JSON.parse(e);t&&this.processJSONRPCresponse(t,this.eventSessionManager)}receiveJSONRPCDecrypted(e){if(e===null)return;const t=JSON.parse(e);t&&this.processJSONRPCresponse(t,this.websocketSessionManager)}processJSONRPCresponse(e,t){const s=t instanceof K?m.Event:m.Websocket;if("result"in e&&e.result!==!1)try{t.invokeCallback(e.id,e),t.unregisterCallback(e.id)}catch(n){t.unregisterCallback(e.id),r.warn("["+s+"] An error occurred when processing the result callback for JSON-RPC object id "+e.id+": "+n)}else if("error"in e)try{r.error("["+s+"] An error occurred in KeePassRPC object id: "+e.id+" with this message: "+e.message+" and this error: "+e.error+" and this error message: "+e.error.message),t.invokeCallback(e.id,e),t.unregisterCallback(e.id)}catch(n){t.unregisterCallback(e.id),r.warn("["+s+"] An error occurred when processing the error callback for JSON-RPC object id "+e.id+": "+n)}else if("method"in e){const n={id:e.id};try{n.result=this.evalJson(e.method,e.params),n.result||(n.result=null)}catch(o){n.error=o,r.error("["+s+"] An error occurred when processing a JSON-RPC request: "+o)}}else"id"in e||r.error("["+s+"] Unexpected error processing receiveJSONRPC")}setupEventSession(e){if(!window.kee.accountManager.featureEnabledMultiSessionTypes&&this.websocketSessionManager.isActive()){r.debug("Session activation aborted: Existing session already active and account does not have the multiple sessions feature."),this.eventSessionManager.closeSession();return}if(!this.serverHasRequiredFeatures(e)){r.error("eventSession: "+$STRF("conn_setup_server_features_missing",["https://www.kee.pm/upgrade-kprpc"])),this.store.updateLatestConnectionError("VERSION_CLIENT_TOO_HIGH");const t={label:$STR("upgrade_kee"),action:"loadUrlUpgradeKee"};this.showConnectionMessage($STRF("conn_setup_server_features_missing",["https://www.kee.pm/upgrade-kprpc"]),[t]),this.eventSessionManager.closeSession();return}this.onConnectStartup()}setupWebsocketSession(){if(!window.kee.accountManager.featureEnabledMultiSessionTypes&&this.eventSessionManager.isActive()){r.debug("Session activation aborted: Existing session already active and account does not have the multiple sessions feature."),this.websocketSessionManager.closeSession();return}try{let e=null,t=null;const s=this.getSecurityLevel(),n=this.getUsername(s);this.getStoredKey(n,s)?e={username:n,securityLevel:s}:(this.srpClientInternals=new ie,this.srpClientInternals.setup(n),t={stage:"identifyToServer",I:this.srpClientInternals.I,A:this.srpClientInternals.Astr,securityLevel:s});const a={protocol:"setup",srp:t,key:e,version:f.versionAsInt(this.clientVersion),features:O.offered,clientTypeId:"keefox",clientDisplayName:"Kee",clientDisplayDescription:$STR("conn_display_description")};this.websocketSessionManager.sendMessage(JSON.stringify(a))}catch(e){r.warn("An attempt to setup the KPRPC secure channel has failed. It will not be retried for at least 10 seconds. If you see this message regularly and are not sure why, please ask on the help forum. Technical detail about the problem follows: "+e),this.websocketSessionManager.connectionProhibitedUntil=new Date,this.websocketSessionManager.connectionProhibitedUntil.setTime(this.websocketSessionManager.connectionProhibitedUntil.getTime()+1e4),this.websocketSessionManager.closeSession(),r.debug("Connection state reset ready for next attempt in at least 10 seconds")}}getUsername(e){let t="";return e<=2&&u.current.KPRPCUsername&&(t=u.current.KPRPCUsername),t.length<=0&&(t=f.newGUID(),u.current.KPRPCUsername=t,u.save()),t}getSecurityLevel(){return u.current.connSLClient}getSecurityLevelServerMinimum(){return u.current.connSLServerMin}getStoredKey(e,t=0){if(e===void 0&&(t=this.getSecurityLevel(),e=this.getUsername(t)),t>=3||t<=0)return null;if(t==2||t==1)return u.current.KPRPCStoredKeys[e]}setStoredKey(e,t,s){t>=3||t<=0||(t==2||t==1)&&(u.current.KPRPCStoredKeys[e]=s,u.save())}removeStoredKey(e,t){(!t||t==2||t==1)&&(u.current.KPRPCStoredKeys[e]="",u.save())}encrypt(e,t){r.debug("starting webcrypto encryption");const s=this,n=crypto.subtle,o=crypto.getRandomValues(new Uint8Array(16)),a=this.secretKey,l=f.stringToByteArray(e),h=f.hexStringToByteArray(a);n.importKey("raw",h,{name:"AES-CBC",length:256},!0,["encrypt","decrypt"]).then(function(w){const S={name:"AES-CBC",iv:o};return n.encrypt(S,w,l)}).then(function(w){n.digest({name:"SHA-1"},h).then(function(T){const P=new Uint8Array(20+w.byteLength+16),I=P.byteLength;P.set(new Uint8Array(T)),P.set(new Uint8Array(w),20),P.set(o,w.byteLength+20),f.hash(P,"base64","SHA-1").then(v=>{const g=P.subarray(I-16),_={message:f.byteArrayToBase64(w),iv:f.byteArrayToBase64(g),hmac:v},x=function(F,D){F(D)};window.setTimeout(x,1,t.bind(s),_)})}).catch(function(T){r.error("Failed to calculate HMAC. Exception: "+T),t(null)})}).catch(function(w){r.error("Failed to encrypt. Exception: "+w),t(null)})}async decrypt(e,t){r.debug("starting webcrypto decryption");const s=this;let n=new Date().getTime();const o=crypto.subtle,a=e.message,l=e.iv,h=e.hmac,p=this.secretKey,w=f.hexStringToByteArray(p),S=f.base64toByteArrayForHMAC(a,36),T=S.length,P=S.subarray(0,20),I=S.subarray(20,T-16),v=S.subarray(T-16);let g=new Date().getTime();r.debug("decryption stage 'data prep 1' took: "+(g-n)),n=g;try{const _=await o.digest({name:"SHA-1"},w);g=new Date().getTime(),r.debug("decryption stage 'key hash' took: "+(g-n)),n=g,P.set(new Uint8Array(_)),f.base64toByteArrayForHMAC(l,0,v),g=new Date().getTime(),r.debug("decryption stage 'data prep 2' took: "+(g-n)),n=g;const F=await f.hash(S,"base64","SHA-1");if(g=new Date().getTime(),r.debug("decryption stage 'generate HMAC' took: "+(g-n)),n=g,F!=h)return;try{const D=await o.importKey("raw",w,{name:"AES-CBC",length:256},!0,["encrypt","decrypt"]);g=new Date().getTime(),r.debug("decryption stage 'import key' took: "+(g-n)),n=g;const G={name:"AES-CBC",iv:v},H=await o.decrypt(G,D,I);g=new Date().getTime(),r.debug("decryption stage 'aes-cbc' took: "+(g-n)),n=g;const q=new TextDecoder("utf-8").decode(H);g=new Date().getTime(),r.debug("decryption stage 'utf-8 conversion' took: "+(g-n)),n=g;const J=function(V,$){V($)};window.setTimeout(J,1,t.bind(s),q)}catch(D){r.error("Failed to decrypt. Exception: "+D),r.warn($STR("conn_setup_restart")),this.store.updateLatestConnectionError("DECRYPTION_FAILED"),s.showConnectionMessage($STR("conn_setup_restart")+" "+$STR("conn_setup_retype_password")),s.removeStoredKey(s.getUsername(s.getSecurityLevel())),s.websocketSessionManager.closeSession(),t(null)}}catch(_){r.error("Failed to hash secret key. Exception: "+_),r.warn($STR("conn_setup_restart")),this.store.updateLatestConnectionError("SECRET_KEY_HASH_FAILED"),s.showConnectionMessage($STR("conn_setup_restart")+" "+$STR("conn_setup_retype_password")),s.removeStoredKey(s.getUsername(s.getSecurityLevel())),s.websocketSessionManager.closeSession(),t(null)}}showConnectionMessage(e,t){window.kee.notifyUser(new oe("kee-connection-message",t||[],f.newGUID(),[e],"Medium"))}}class le{constructor(){this.kprpcClient=new ce,this.kprpcClient.startWebsocketSessionManager(),this.store=E()}startEventSession(e,t,s){return this.kprpcClient.startEventSession(e,t,s)}eventSessionMessageFromPage(e){return this.kprpcClient.eventSessionMessageFromPage(e)}sessionManagerForFilename(e){const t=this.store.KeePassDatabases.find(s=>s.fileName===e).sessionType;return this.kprpcClient.getSessionManagerByType(t)}sessionManagerForPasswordProfile(e){const t=this.store.PasswordProfiles.find(s=>s.name===e).sessionType;return this.kprpcClient.getSessionManagerByType(t)}get eventSessionManagerIsActive(){return this.kprpcClient.getSessionManagerByType(m.Event).isActive()}get websocketSessionManagerIsActive(){return this.kprpcClient.getSessionManagerByType(m.Websocket).isActive()}launchGroupEditor(e,t){this.kprpcClient.request([this.sessionManagerForFilename(t)],"LaunchGroupEditor",[e,t])}launchLoginEditor(e,t){this.kprpcClient.request([this.sessionManagerForFilename(t)],"LaunchLoginEditor",[e,t])}selectAndFocusDatabase(e,t){let s;const n=this.kprpcClient.getSessionManagerByType(m.Event),o=this.kprpcClient.getSessionManagerByType(m.Websocket);return n.isActive()&&o.isActive()?e&&!t?s=n:t&&!e?s=o:s=n:n.isActive()?s=n:o.isActive()&&(s=o),s?(s instanceof N&&this.kprpcClient.request([s],"OpenAndFocusDatabase",[t,!1]),s instanceof K?m.Event:m.Websocket):(r.info("No active session found"),null)}selectDB(e,t,s){const n=s?this.kprpcClient.getSessionManagerByType(s):null;if(t)this.kprpcClient.request([n],"ChangeDatabase",[e,!1]);else{if(n instanceof K){r.error("Kee Vault does not support OpenAndFocusDatabase feature");return}this.kprpcClient.request([n],"OpenAndFocusDatabase",[e,t])}}async addLogin(e,t,s){var l;const n=y.toKPRPCEntryDTO(e),o=await this.kprpcClient.request([this.sessionManagerForFilename(s)],"AddLogin",[n,t,s]),a=(l=o==null?void 0:o[0].resultWrapper)==null?void 0:l.result;if(a){const h=U.fromKPRPCDatabaseSummaryDTO(a.db);return y.fromKPRPCEntryDTO(a,h)}return null}async updateLogin(e,t,s){var p;const n=y.toKPRPCEntryDTO(e),o=this.sessionManagerForFilename(s),a=o.features().some(w=>w==="KPRPC_FEATURE_ENTRY_URL_REPLACEMENT")?5:2,l=await this.kprpcClient.request([o],"UpdateLogin",[n,t,a,s]),h=(p=l==null?void 0:l[0].resultWrapper)==null?void 0:p.result;if(h){const w=U.fromKPRPCDatabaseSummaryDTO(h.db);return y.fromKPRPCEntryDTO(h,w)}return null}async findLogins(e,t,s,n,o,a){var P,I;if(this.store.KeePassDatabases.length<=0)return[];const l="LSTnoForms";(n==null||n==null||n=="")&&(u.current.searchAllOpenDBs?n="":n=this.store.KeePassDatabases[this.store.ActiveKeePassDatabaseIndex].fileName);const h=[];n?h.push(this.sessionManagerForFilename(n)):h.push(...this.kprpcClient.getManagersForActiveSessions());const p=h.filter(v=>v instanceof K&&this.store.KeePassDatabases.some(g=>g.sessionType==m.Event)||v instanceof N&&this.store.KeePassDatabases.some(g=>g.sessionType==m.Websocket));if(p.length<=0)return[];const w=[];e&&(w.push(e),e.search(/$https:\/\/accounts\.youtube\.com\/?/)>=0&&w.push("https://accounts.google.com"));const S=await this.kprpcClient.request(p,"FindLogins",[w,null,t,l,!1,s,n,o,a]),T=[];for(const v of S)if((I=(P=v.resultWrapper)==null?void 0:P.result)!=null&&I[0]){const g=U.fromKPRPCDatabaseSummaryDTO(v.resultWrapper.result[0].db);T.push(...v.resultWrapper.result.map(_=>y.fromKPRPCEntryDTO(_,g)))}return T}async getAllDatabases(){const e=this.kprpcClient.getManagersForActiveSessions(),t=await this.kprpcClient.request(e,"GetAllDatabases",null),s=[];t.sort(n=>n.sessionType===m.Event?-1:1);for(const n of t)if(n.resultWrapper.result!==null){const o=n.sessionType===m.Event?n.resultWrapper.result.dbs:n.resultWrapper.result;for(const a of o)s.find(l=>l.fileName===a.fileName)?r.debug("Database with duplicate file name found. Ignoring."):s.push(Z.fromKPRPCDatabaseDTO(a,n.sessionType,n.features));n.sessionType===m.Event&&window.kee.configSyncManager.updateFromRemoteConfig(n.resultWrapper.result.config)}window.kee.updateKeePassDatabases(s)}updateAddonSettings(e,t){const s=this.kprpcClient.getSessionManagerByType(m.Event);s&&this.kprpcClient.request([s],"UpdateAddonSettings",[e,t])}async getPasswordProfiles(){const e=this.kprpcClient.getManagersForActiveSessions(),t=await this.kprpcClient.request(e,"GetPasswordProfiles",null),s=[];t.sort(n=>n.sessionType===m.Event?-1:1);for(const n of t)if(n.resultWrapper.result!==null)for(const o of n.resultWrapper.result)s.find(a=>a.name===o)?r.debug("Password profile with duplicate name found. Ignoring."):s.push({name:o,sessionType:n.sessionType});return s}async generatePassword(e,t){const s=this.sessionManagerForPasswordProfile(e),o=(await this.kprpcClient.request([s],"GeneratePassword",[e,t]))[0];if(o.resultWrapper.result!==null)return o.resultWrapper.result}}class ue{constructor(){this.enabled=!1}updateFromRemoteConfig(e){!e||!e.settings||!e.version||(e.version!==u.current.version&&u.migrateFromRemoteToLatestVersion(),this.enabled=!0,this.lastKnownSynced=JSON.parse(JSON.stringify(e)),u.setASAP(e.settings))}updateToRemoteConfig(e){if(!this.enabled)return;const t={autoFillForms:e.autoFillForms,autoFillFormsWithMultipleMatches:e.autoFillFormsWithMultipleMatches,autoSubmitForms:e.autoSubmitForms,autoSubmitMatchedForms:e.autoSubmitMatchedForms,listAllOpenDBs:e.listAllOpenDBs,logLevel:e.logLevel,mruGroup:e.mruGroup,notifyWhenEntryUpdated:e.notifyWhenEntryUpdated,overWriteFieldsAutomatically:e.overWriteFieldsAutomatically,rememberMRUDB:e.rememberMRUDB,rememberMRUGroup:e.rememberMRUGroup,saveFavicons:e.saveFavicons,searchAllOpenDBs:e.searchAllOpenDBs,siteConfig:e.siteConfig,autoSubmitNetworkAuthWithSingleMatch:e.autoSubmitNetworkAuthWithSingleMatch,notificationCountGeneric:e.notificationCountGeneric,notificationCountSavePassword:e.notificationCountSavePassword,currentSearchTermTimeout:e.currentSearchTermTimeout,animateWhenOfferingSave:e.animateWhenOfferingSave,manualSubmitOverrideProhibited:!!e.manualSubmitOverrideProhibited,autoFillFieldsWithExistingValue:e.autoFillFieldsWithExistingValue},s={settings:t,version:e.version};if(window["fast-equals"].deepEqual(s,this.lastKnownSynced))return;const n=JSON.stringify(s);r.debug(`Config different. latest: ${n} this.lastKnownSynced: ${JSON.stringify(this.lastKnownSynced)}`);try{window.kee.KeePassRPC.updateAddonSettings(t,e.version),this.lastKnownSynced=JSON.parse(JSON.stringify(s))}catch(o){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+o),o}}reset(){this.enabled=!1,this.lastKnownSynced=null}}class de{constructor(){this.pendingRequests=[],this.store=E()}completed(e){const t=this.pendingRequests.indexOf(e.requestId);t>-1&&this.pendingRequests.splice(t,1)}provideCredentialsAsyncBlockingCallback(e,t){this.provideCredentialsAsync(e).then(s=>t(s)).catch(s=>{r.error("AsyncBlockingCallback promise failed: "+s),t({cancel:!1})})}async provideCredentialsAsync(e){if(this.pendingRequests.push(e.requestId),r.debug("Providing credentials for: "+e.requestId),!this.store.connected||this.store.ActiveKeePassDatabaseIndex<0)return{cancel:!1};const t=new URL(e.url);t.hostname=punycode.toUnicode(t.hostname);const s=await window.kee.findLogins(t.href,e.realm,null,null,null,null);let n=[],o=!1;try{s?n=s.filter(a=>y.getUsernameField(a)&&y.getPasswordField(a)):o=!0}catch{o=!0}if(o||n.length<=0)return{cancel:!1};if(n.length===1&&u.current.autoSubmitNetworkAuthWithSingleMatch){const a=n[0];return{authCredentials:{username:y.getUsernameField(a).value,password:y.getPasswordField(a).value}}}return n.sort((a,l)=>l.httpRealm===e.realm?1:0),new Promise(a=>{function l(p,w){switch(p.action){case"NetworkAuth_ok":{const S=n[p.selectedEntryIndex];a({authCredentials:{username:y.getUsernameField(S).value,password:y.getPasswordField(S).value}}),c.runtime.onMessage.removeListener(l);break}case"NetworkAuth_cancel":{a({cancel:!1}),c.runtime.onMessage.removeListener(l);break}case"NetworkAuth_load":{c.tabs.sendMessage(w.tab.id,{action:"NetworkAuth_matchedEntries",entries:n,realm:e.realm,url:t.href,isProxy:e.isProxy});break}}}c.runtime.onMessage.addListener(l);const h={type:"popup",url:"/dialogs/NetworkAuth.html",width:600,height:300};c.windows.create(h)})}startListening(){__KeeIsRunningInAWebExtensionsBrowser?c.webRequest.onAuthRequired.addListener(e=>this.provideCredentialsAsync(e),{urls:["<all_urls>"]},["blocking"]):chrome.webRequest.onAuthRequired.addListener((e,t)=>{this.provideCredentialsAsyncBlockingCallback(e,t)},{urls:["<all_urls>"]},["asyncBlocking"]),c.webRequest.onCompleted.addListener(e=>{this.completed(e)},{urls:["<all_urls>"]}),c.webRequest.onErrorOccurred.addListener(e=>{this.completed(e)},{urls:["<all_urls>"]}),r.debug("Network authentication listeners started")}}class he{constructor(){this.timer=null,this.cache=[],this.loadingImage=!1,this.KEE_ICON_48="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACxQAAAsUBidZ/7wAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAOdEVYdFRpdGxlAEtlZSBsb2dvN59B9AAAABB0RVh0QXV0aG9yAEtlZSBWYXVsdGXwy5UAAAa9SURBVGiBtZlrbBzVFYC/M+v1ev0I2IkdG6gUU6eFPFqpBpNAUUulIhXRVqhCELWqWrWiVQGh/mhp1RKZPxVUaoXxE1cxVEIKkEJbpzKJH8Twg5IgN0oaV8RJiHFt764faxLver2Pmdsf8TrrfczcXW+/X7v3njmPmTvn3nNGSOGm+594BFQr0ASU4EwCONqwGH9kbKw3rh5rdvvdkYew5CEl3CuKeiVKBALKkFEx1V/rTe/fpHcs3tz8mNu3teQNkAe1bSkmQH49O9TRnxyU5I/6bzy5yzCtM5rK0lDf+nDnqGEo+aOCWwGCppuxSDUAzd4lalzxawaFS5bi53deuE8Q9ff8bRE1RO2ZPt51kVRnXQmzRYkU4DxWx81nD4iSR9XaDflgpZpfBXYTMq+pqzISPFc/zl3lSyjFZwX6O246c/gJ3xcswMjTnkcpuQe4yIaLRRYKcJ6f1EzG93mXDrDm/KoyOBjYte48wLJVwsG524la183tqwge+P6N/40XYtOyxJ/8va4xFlOjQCQfRfsrgvy4ZtKTOjYRrSRoujNkFxOlTMQqN4z9bOvHnmbvlXxMAgRqqredSP5ZD2B+tCsEHNbVIsBTNZeuv0RrlBtmzmvS50pE8YvaiQwdDpZ7xo+0xpL/Nqw/w7DadNW0lC/R5AlnjDeWhtntuZoxvrfsCo2lKxnjTaVh7ihf0jUbjZdYPakDGwKYPtZ9FnhHR9OXyxezjruA3zeM0+INIlx7UneVL/F8/X8wUFmvuTeHrnQU8vr8QJc/dSwz6yhpQ9TXnJTtLsu8y0m2l0TpuvksIcsFQKXNsgLYY6MrFRGVsUIyUtjsPdv+wVqKsqPGFXMSodIwHZ0HqHYlHGWA92aPd/4rfTAzB7e2WkC7kzZL5Zu+c5PIvrI2oBQvZBvP6kWsLPIyYJvf5s1SDdf0WDA9TiKTvhvn+rNNZA1gob9vWQmH7DSeiWzR806D05EbbOdF0c6RI1nXYs51YCnpAHIu4HfCtbr+OXIivM1uOuSOu/tyTeYMIDDYcRnI+tgAPopW8eFKtZaDdpxcqeZCtDK3gPDnydEXPs01bfsmKrK/OEmem//chvNNvqwqg+cXdtq7IJZtQrG17hvsfA/ISF1JPol7eXb+ttzrzAYTeNZ/G1Ox8txCSgZmj3Wft9PjePuybR6pDC7X8Vv/LsLK5aRqnbBy8Rv/LobCdQ7G7W2DRgBew/U64LeTGQrV8b2pZkZCtTkOC9dQwEiolu9O3cFwyMF5GJ8d7Bx2EnK8bcGLp8yqppYK4D47uauWm+FQHauWi305Dme/m/s87Yu3ctXKPG6no5BnQpdOjTnJab2BpjJ7gFUdWV8ic1MygYHl7QwuO971JIviib2qI6gVQGCwZw6lXyuk0xts5GDg9jzeE/nT7NHezLN3FrRzoBiGdq2Qzk9rLvOHhnO2xU4KcXFJp65u7QBmjrefAU44CmZBgK9ULPAZt9ZNfXPm7fZpXd357UJCQU/h36tbeHz2i5yPVjmbsPSrQsgzgNn9tUeBS/lcM7C8nR9Of4mTeseOkzPD3R/koz+/J9DaaikljrVCKg9UBWhvOMveMo3ug3LeuNLJ+yAT9670AXo14Br7K4L03XKanZ6QndhMQzDxl3z9yTuAhf6+ZYXY1grZeD+8FV+8LOe8gs6xsd68G10FHSUty7StFdJ5aXEHT/n2ErJydi4jhklvIb4UFEBguPtjbGqFdH5U8wnP1J3HY1g5JOTVmZFOvd5KGgUf5i2ln+5KRPHtLT6a3JmNMECZJF4s1I+CA/APdb+LqNM6spdj5Tzt28141n1AjQQGe84V6semeiOiROspnIvewKlI9n1A0NORi00F4HUZr+FQKwB8s8rH0R3/ZEdGb1RdmLm7dmAzPmwqgItvt0dBbWi2ziUyU2XEcvHap7cwk55GhRfXGmkFs+n2WsJ09wDR5P+PopVqOsXRiOXi4ak76Qk2Et/YzbsSj/LKZu1vOoC5kbYAcr1WiClDfunfs16sL1lu/FmeihIOrX2T2BSFfBPLQCzVpkR+kPw/Ea3k4akWGj1hrOwLxFxrnG3edjGUADR8/fETInxVy6iSt2aGOr5TDLtFazGL6KdDS6NdokvRApi9e1s/OrWCqNNrDbOiULwmf2urpQTHdS0O7cp8KV4AQNwTOYT9d4U5d3TljWLaLGoAC/19ywIv55ZQXZOjr2j1l3QpagAApmG2kb1WiMZLeKnY9ooegP9YzyRIxgcJEdWT/om0GBRlI0un3CVPrpgqATwKKITDXsP19P/D1v8A9c9y4AkuIcMAAAAASUVORK5CYII=",this.IMG_SIZE=48}start(e,t){if(this.loadingImage)return;this.timer!==null&&(clearInterval(this.timer),this.timer=null);const s=t?17:100;if(this.timeStarted=Date.now(),this.duration=t?e:1600,!t){this.timer=window.setInterval(()=>this.drawLowFramerate(),s);return}if(this.cache.length>0){this.timer=window.setInterval(()=>this.draw(),s);return}else{const n=document.createElement("canvas");n.height=this.IMG_SIZE,n.width=this.IMG_SIZE;const o=n.getContext("2d"),a=document.createElement("img");a.addEventListener("load",()=>{this.buildCache(o,a),this.timer=window.setInterval(()=>this.draw(),s),this.loadingImage=!1}),this.loadingImage=!0,a.src=this.KEE_ICON_48}}buildCache(e,t){const s=Date.now(),n=this.IMG_SIZE/2;for(let o=0;o<=this.IMG_SIZE;o++){e.clearRect(0,0,this.IMG_SIZE,this.IMG_SIZE);const a=13*this.IMG_SIZE/16-o/2,l=e.createRadialGradient(n,n,n/8,n,n,a);l.addColorStop(0,"rgb(255, 255, 165, 1)"),l.addColorStop(.6,"rgb(255, 255, 0, 1)"),l.addColorStop(1,"rgb(255, 255, 165, 0)"),e.fillStyle=l,e.fillRect(0,0,48,48);const h=n-o/2;e.drawImage(t,h,0,o,this.IMG_SIZE);const p=e.getImageData(0,0,this.IMG_SIZE,this.IMG_SIZE);this.cache[o]=p}r.debug("Animated icon cache build time: "+(Date.now()-s))}drawLowFramerate(){const e=Date.now()-this.timeStarted;if(e>this.duration){clearInterval(this.timer),this.timer=null,c.browserAction.setIcon({path:"common/images/48.png"});return}e/this.duration*16%4<2?c.browserAction.setIcon({path:"common/images/highlight-48.png"}):c.browserAction.setIcon({path:"common/images/48.png"})}draw(){const e=Date.now()-this.timeStarted;if(e>this.duration){clearInterval(this.timer),this.timer=null,c.browserAction.setIcon({path:"common/images/48.png"});return}const t=e/this.duration,s=Math.abs(this.IMG_SIZE*Math.cos(Math.PI*2*t)),n=this.cache[Math.round(s)];c.browserAction.setIcon({imageData:n})}}var C=(i=>(i.DetectForms="detect-forms",i.PrimaryAction="primary-action",i.GeneratePassword="generate-password",i))(C||{});const R=E();class pe{constructor(){this.contextMenuUpdateLock=!1}init(){c.commands.onCommand.addListener(e=>{switch(e){case C.DetectForms:R.connected&&R.ActiveKeePassDatabaseIndex>=0&&window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.forEach(t=>{t.postMessage({action:b.DetectForms})},this);break;case C.PrimaryAction:R.ActiveKeePassDatabaseIndex<0?window.kee.loginToPasswordManager():window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.forEach(t=>{t.postMessage({action:b.Primary})},this);break;case C.GeneratePassword:window.kee.initiatePasswordGeneration();break}}),c.contextMenus.onClicked.addListener(e=>{const t=e.menuItemId;switch(t){case C.DetectForms:R.connected&&R.ActiveKeePassDatabaseIndex>=0&&window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.forEach(s=>{s.postMessage({action:b.DetectForms})},this);break;case C.GeneratePassword:window.kee.initiatePasswordGeneration();break}t.startsWith("matchedLogin-")&&window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.get(e.frameId).postMessage({action:b.ManualFill,selectedEntryIndex:t.substr(t.indexOf("-")+1)})})}async setupContextMenuItems(){if(M.contextMenuUpdateLock){r.debug("If you are missing entries from your context menu, we will need to spend more effort on the setupContextMenuItems implementation (wait by using semaphores rather than assuming new search results always follow setup requests with no results)");return}M.contextMenuUpdateLock=!0;try{if(await c.contextMenus.removeAll(),R.connected&&R.ActiveKeePassDatabaseIndex>=0)try{c.contextMenus.create({id:C.DetectForms,title:$STR("Menu_Button_fillCurrentDocument_label"),documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","password","selection"]})}catch{c.contextMenus.create({id:C.DetectForms,title:$STR("Menu_Button_fillCurrentDocument_label"),documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","selection"]})}if(R.connected)try{c.contextMenus.create({id:C.GeneratePassword,title:$STR("Menu_Button_copyNewPasswordToClipboard_label"),documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","password","selection"]})}catch{c.contextMenus.create({id:C.GeneratePassword,title:$STR("Menu_Button_copyNewPasswordToClipboard_label"),documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","selection"]})}window.kee.foregroundTabId>=0&&window.kee.tabStates.has(window.kee.foregroundTabId)&&window.kee.tabStates.get(window.kee.foregroundTabId).frames&&window.kee.tabStates.get(window.kee.foregroundTabId).frames.forEach(e=>{for(let t=0;t<e.entries.length;t++){const s=e.entries[t];try{c.contextMenus.create({id:"matchedLogin-"+t,title:s.title,documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","password","selection"]})}catch{c.contextMenus.create({id:"matchedLogin-"+t,title:s.title,documentUrlPatterns:["http://*/*","https://*/*"],contexts:["editable","frame","image","link","page","selection"]})}}})}finally{M.contextMenuUpdateLock=!1}}}const M=new pe;M.init();var L=(i=>(i.Init="init",i.MessageToClient="messageToClient",i.FocusRequired="focusRequired",i.AccountChanged="accountChanged",i))(L||{});const A=E();async function we(i){if(i.mutation&&window.kee.syncBackground.onMessage(this,i.mutation),r&&r.debug&&r.debug("In background script, received message from browser popup script."),i.removeNotification&&window.kee.removeUserNotifications(e=>e.id!=i.removeNotification),i.loadUrlUpgradeKee&&c.tabs.create({url:"https://www.kee.pm/upgrade-kprpc"}),i.action==b.GetPasswordProfiles){const e=await window.kee.getPasswordProfiles();A.updatePasswordProfiles(e)}if(i.action===b.GeneratePassword){const e=await window.kee.generatePassword(i.passwordProfile,i.url??"unknown URL");e?A.updateGeneratedPassword(e):r.warn("Kee received an empty/missing password. Check the configuration of your password manager.")}if((i.action===b.CreateEntry||i.action===b.UpdateEntry)&&A.connected){const e=A.saveState.newEntry,t=e.uuid,s=e.database.fileName,n=e.parentGroup.uuid,o=new y(Object.assign(Object.assign({},e),{parentGroup:void 0,uuid:null,database:void 0,icon:u.current.saveFavicons?{version:1,iconImageData:A.saveState.favicon}:null})),a=window.kee.foregroundTabId,l=()=>{var h,p;((p=(h=window.kee.persistentTabStates.get(a))==null?void 0:h.items)==null?void 0:p.length)>0&&(window.kee.persistentTabStates.get(a).items=window.kee.persistentTabStates.get(a).items.filter(w=>w.itemType!=="submittedData"))};i.action===b.UpdateEntry?(A.updateEntryUpdateStartedAtTimestamp(Date.now()),window.kee.updateLogin(o,t,s,l)):window.kee.addLogin(o,n,s,l),u.current.mruGroup||(u.current.mruGroup={}),u.current.mruGroup[s]=n,u.current.mruGroup["{<{{<<kee-primary>>}}>}"]=n,u.save()}if(i.action==b.ManualFill&&i.selectedEntryIndex!=null&&(window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.get(i.frameId||0).postMessage(i),window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.get(0).postMessage({action:b.CloseAllPanels})),i.action===b.OpenKeePass&&window.kee.openKeePass(),i.findMatches){const e=await window.kee.findLogins(null,null,i.findMatches.uuid,i.findMatches.DBfilename,null,null);window.kee.browserPopupPort.postMessage({findMatchesResult:e})}i.loginEditor&&window.kee.launchLoginEditor(i.loginEditor.uuid,i.loginEditor.DBfilename),i.action===b.DetectForms&&window.kee.tabStates.get(window.kee.foregroundTabId).framePorts.forEach(e=>{e.postMessage({action:b.DetectForms})},this)}async function ge(i){if(i.mutation&&window.kee.syncBackground.onMessage(this,i.mutation),r&&r.debug&&r.debug("In background script, received message from page script."),i.findMatches){window.kee.tabStates.get(this.sender.tab.id).frames.get(this.sender.frameId).entries=[];const e=await window.kee.findLogins(i.findMatches.uri,null,null,null,null,null);this.postMessage({isForegroundTab:this.sender.tab.id===window.kee.foregroundTabId,findMatchesResult:e})}if(i.removeNotification){window.kee.removeUserNotifications(e=>e.id!=i.removeNotification);try{window.kee.browserPopupPort.postMessage({isForegroundTab:this.sender.tab.id===window.kee.foregroundTabId})}catch{}}if(i.entries&&(window.kee.tabStates.get(this.sender.tab.id).frames.get(this.sender.frameId).entries=i.entries),i.submittedData){const e={itemType:"submittedData",submittedData:i.submittedData,creationDate:new Date};if(window.kee.persistentTabStates.get(this.sender.tab.id)||window.kee.persistentTabStates.set(this.sender.tab.id,{items:[]}),window.kee.persistentTabStates.get(this.sender.tab.id)&&(window.kee.persistentTabStates.get(this.sender.tab.id).items=window.kee.persistentTabStates.get(this.sender.tab.id).items.filter(t=>t.itemType!=="submittedData")),window.kee.persistentTabStates.get(this.sender.tab.id).items.push(e),A.entryUpdateStartedAtTimestamp>=Date.now()-9e4)return;u.current.notificationCountSavePassword<10&&(c.notifications.create({type:"basic",iconUrl:c.extension.getURL("common/images/128.png"),title:$STR("savePasswordText"),message:$STR("notification_save_password_tip")+`
`+$STR("notification_only_shown_some_times")}),u.setASAP({notificationCountSavePassword:u.current.notificationCountSavePassword+1})),u.current.animateWhenOfferingSave&&window.kee.animateBrowserActionIcon()}if(i.action===b.ShowMatchedLoginsPanel&&window.kee.tabStates.get(this.sender.tab.id).framePorts.get(0).postMessage({action:b.ShowMatchedLoginsPanel,frameId:this.sender.frameId}),i.action===b.PageHide){try{window.kee.tabStates.get(this.sender.frameId).framePorts.forEach((e,t,s)=>{try{e.disconnect()}catch(n){r&&r.debug&&r.debug("failed to disconnect a frame port on tab "+t+". This is probably not a problem but we may now be reliant on browser GC to clear down memory. The exception that caused this is: "+n.message+" : "+n.stack)}finally{s.delete(t)}})}catch{}this.sender.frameId===0&&window.kee.deleteTabState(this.sender.tab.id)}}function fe(i){i.mutation&&window.kee.syncBackground.onMessage(this,i.mutation);let e;switch(r&&r.debug&&r.debug("In background script, received message from vault script."),i.action){case L.Init:e=window.kee.KeePassRPC.startEventSession(i.sessionId,i.features,t=>this.postMessage(t)),e&&this.postMessage(e);return;case L.MessageToClient:e=window.kee.KeePassRPC.eventSessionMessageFromPage(i),e&&this.postMessage(e);return;case L.FocusRequired:c.tabs.update(this.sender.tab.id,{active:!0}),c.windows.update(this.sender.tab.windowId,{focused:!0});return;case L.AccountChanged:window.kee.accountManager.processNewTokens(i.tokens);return}}async function be(i){i.mutation&&window.kee.syncBackground.onMessage(this,i.mutation),r&&r.debug&&r.debug("In background script, received message from iframe script.");const e=this.sender.tab.id;if(i.action==b.ManualFill&&i.selectedEntryIndex!=null&&(window.kee.tabStates.get(e).framePorts.get(i.frameId||0).postMessage(i),window.kee.tabStates.get(e).framePorts.get(0).postMessage({action:b.CloseAllPanels})),i.action==b.CloseAllPanels&&window.kee.tabStates.get(e).framePorts.get(0).postMessage(i),i.action==b.GetPasswordProfiles){const t=await window.kee.getPasswordProfiles();A.updatePasswordProfiles(t)}if(i.action==b.GeneratePassword){const t=await window.kee.generatePassword(i.passwordProfile,window.kee.tabStates.get(e).url);t?(A.updateGeneratedPassword(t),this.postMessage({generatedPassword:t})):r.warn("Kee received an empty/missing password. Check the configuration of your password manager.")}i.loginEditor&&window.kee.launchLoginEditor(i.loginEditor.uuid,i.loginEditor.DBfilename),i.copyToClipboard&&await Q(i.copyToClipboard)}class me{constructor(){this.frames=new Map,this.url="",this.framePorts=new Map,this.ourIframePorts=new Map}}class Se{constructor(){this.entries=[]}}class ke{constructor(e,t){this.store=e,this.distributeMutation=t,this.receivedMutations=[],e.$subscribe((s,n)=>{if(s.type==j.patchObject){for(let o=0;o<this.receivedMutations.length;o++)if(this.receivedMutations[o]==s.payload){this.receivedMutations.splice(o,1);return}r.debug("local mutation so distributing mutation"),this.distributeMutation(s,null)}else throw r.error("mutation type: "+s.type),new Error("Pinia generated a non-object mutation. We don't think we can support this and need to know that it is possible for it to happen! Tell us now or weird things will happen.")},{flush:"sync"})}onMessage(e,t){this.receivedMutations.push(t),this.store.$patch(t.payload),r.debug("SyncBackground.onMessage distributing"),this.distributeMutation(t,e)}}const d=E();class ye{constructor(){this.configSyncManager=new ue,this.syncBackground=new ke(d,(e,t)=>{const s=[];s.push(this.browserPopupPort),s.push(this.vaultPort);const n=window.kee.tabStates.get(window.kee.foregroundTabId);n&&(n.framePorts.forEach(o=>{s.push(o)}),n.ourIframePorts.forEach(o=>{s.push(o)}));for(const o of s)if(o!==t)try{o.postMessage({mutation:e})}catch{}}),this.accountManager=new ne,this.tabStates=new Map,this.persistentTabStates=new Map,this.foregroundTabId=-1,this.utils=f,this.search=new X(d.$state,{version:1,searchAllDatabases:u.current.searchAllOpenDBs}),this.networkAuth=new de,this.animateIcon=new he,this.browserPopupPort={postMessage:e=>{}},this.vaultPort={postMessage:e=>{}},this.onPortConnected=function(e){var n,o;r&&r.debug&&r.debug(e.name+" port connected");let t=e.name,s;switch(t.startsWith("iframe")&&(s=parseInt(t.substr(7)),t="iframe"),t){case"browserPopup":{clearTimeout(window.kee.currentSearchTermTimer),e.onMessage.addListener(we.bind(e)),e.onDisconnect.addListener(()=>{window.kee.browserPopupPort={postMessage:p=>{}},window.kee.currentSearchTermTimer=window.setTimeout(()=>{d.updateCurrentSearchTerm(null),d.updateSearchResults(null)},u.current.currentSearchTermTimeout*1e3)});const a={initialState:d.$state};let l=null,h=!1;if(window.kee.persistentTabStates.get(window.kee.foregroundTabId)&&window.kee.persistentTabStates.get(window.kee.foregroundTabId).items.forEach(p=>{p.itemType==="submittedData"&&(l=p.submittedData)}),window.kee.tabStates.has(window.kee.foregroundTabId)){const p=window.kee.tabStates.get(window.kee.foregroundTabId).frames,w=window.kee.frameIdWithMatchedLogins(p);w>=0&&(h=!0,a.entries=p.get(w).entries,a.frameId=w,a.tabId=window.kee.foregroundTabId)}d.updateSubmittedData(l),d.updateLoginsFound(h),e.postMessage(a),window.kee.browserPopupPort=e,window.kee.resetBrowserActionColor();break}case"page":{e.onMessage.addListener(ge.bind(e));const a=e.sender.tab.id,l=e.sender.frameId,h={initialState:d.$state,frameId:l,tabId:a,isForegroundTab:a===window.kee.foregroundTabId};window.kee.createTabStateIfMissing(a),l===0&&(window.kee.tabStates.get(a).url=e.sender.tab.url,((o=(n=window.kee.persistentTabStates.get(a))==null?void 0:n.items)==null?void 0:o.length)>0&&(window.kee.persistentTabStates.get(a).items=window.kee.persistentTabStates.get(a).items.filter(p=>p.itemType!=="submittedData"||p.creationDate>new Date(Date.now()-36e5)))),window.kee.tabStates.get(a).frames.set(l,new Se),window.kee.tabStates.get(a).framePorts.set(l,e),e.postMessage(h);break}case"vault":{e.onMessage.addListener(fe.bind(e));const a={initialState:d.$state,frameId:e.sender.frameId,tabId:e.sender.tab.id,isForegroundTab:e.sender.tab.id===window.kee.foregroundTabId};window.kee.vaultPort=e,e.postMessage(a);break}case"iframe":{e.onMessage.addListener(be.bind(e));const a={initialState:d.$state,frameState:window.kee.tabStates.get(e.sender.tab.id).frames.get(s),frameId:e.sender.frameId,tabId:e.sender.tab.id,isForegroundTab:e.sender.tab.id===window.kee.foregroundTabId};window.kee.persistentTabStates.get(e.sender.tab.id)&&window.kee.persistentTabStates.get(e.sender.tab.id).items.forEach(l=>{l.itemType==="submittedData"&&(a.submittedData=l.submittedData)}),e.postMessage(a),window.kee.tabStates.get(e.sender.tab.id).ourIframePorts.set(e.sender.frameId,e);break}}}}frameIdWithMatchedLogins(e){let t=-1;return e.forEach((s,n)=>{t==-1&&s&&s.entries&&s.entries.length>0&&(t=n)}),t}async init(){this.regularKPRPCListenerQueueHandlerTimer=window.setInterval(this.RegularKPRPCListenerQueueHandler,5e3),this._keeBrowserStartup(),this.accountManager.addListener(()=>{this.accountManager.featureEnabledMultiSessionTypes&&!this.KeePassRPC.eventSessionManagerIsActive&&this.inviteKeeVaultConnection()}),c.runtime.onConnect.addListener(this.onPortConnected),this.networkAuth.startListening(),await c.privacy.services.passwordSavingEnabled.set({value:!1}),c.runtime.lastError!=null&&r.warn("KeeFox was unable to disable built-in password manager saving - confusion may ensue! "+c.runtime.lastError.message)}notifyUser(e,t){window.kee.removeUserNotifications(s=>s.name!=e.name),d.addNotification(e),c.browserAction.setIcon({path:"common/images/highlight-48.png"}),t?c.notifications.create({type:"basic",iconUrl:c.extension.getURL("common/images/128.png"),title:t.title,message:t.message}):u.current.notificationCountGeneric<5&&(c.notifications.create({type:"basic",iconUrl:c.extension.getURL("common/images/128.png"),title:$STR("notification_raised_title"),message:$STR("notification_yellow_background")+`
`+$STR("notification_only_shown_some_times")}),u.setASAP({notificationCountGeneric:u.current.notificationCountGeneric+1}))}removeUserNotifications(e){d.updateNotifications(d.notifications.filter(e))}animateBrowserActionIcon(e=1200){this.animateIcon.start(e,!__KeeIsRunningInAWebExtensionsBrowser)}resetBrowserActionColor(){c.browserAction.setIcon({path:"common/images/48.png"})}shutdown(){r.debug("Kee module shutting down..."),r.debug("Kee module shut down.")}_keeBrowserStartup(){r.debug("Kee initialising"),this.KeePassRPC=new le,r.info("Kee initialised OK although the connection to a KeePassRPC server is probably not established just yet...")}_pauseKee(){r.debug("Pausing Kee."),d.updateKeePassDatabases([]),d.updateActiveKeePassDatabaseIndex(-1),d.updateConnected(!1),d.updateConnectedWebsocket(!1),d.updateCurrentSearchTerm(null),d.updateSearchResults(null);try{this.refreshFormStatus(b.ResetForms)}catch(e){r.error("Uncaught exception posting message in _pauseKee: "+e.message+" : "+e.stack)}c.browserAction.setBadgeText({text:"OFF"}),c.browserAction.setBadgeBackgroundColor({color:"red"}),M.setupContextMenuItems(),r.info("Kee paused.")}_refreshKPDB(){this.getAllDatabases(),r.debug("Refresh of Kee's view of the KeePass database initiated.")}inviteKeeVaultConnection(){this.vaultPort&&this.vaultPort.postMessage({protocol:k.Reconnect})}updateKeePassDatabases(e){let t=-1;for(let s=0;s<e.length;s++)if(e[s].active){t=s;break}if(d.updateConnected(!0),d.updateConnectedWebsocket(this.KeePassRPC.websocketSessionManagerIsActive),d.updateKeePassDatabases(e),d.updateActiveKeePassDatabaseIndex(t),d.updateSearchResults(null),d.updateCurrentSearchTerm(null),r.info("Number of databases open: "+e.length),e.length>0?(c.browserAction.setBadgeText({text:""}),c.browserAction.setBadgeBackgroundColor({color:"blue"})):(c.browserAction.setBadgeText({text:"OFF"}),c.browserAction.setBadgeBackgroundColor({color:"orange"})),u.current.rememberMRUDB){const s=this.getDatabaseFileName();s!=null&&s!=null&&(u.current.keePassMRUDB=s),u.save()}try{this.refreshFormStatus(b.DetectForms)}catch(s){r.error("Uncaught exception posting message in updateKeePassDatabases: "+s.message+" : "+s.stack)}M.setupContextMenuItems()}refreshFormStatus(e){window.kee.tabStates.forEach((t,s)=>{t.framePorts.forEach((n,o,a)=>{try{n.sender.tab.id===this.foregroundTabId&&n.postMessage({action:e})}catch(l){r&&r.info&&r.info("failed to request form field reset/update on tab "+s+". Assuming port is broken (possible browser bug) and deleting the port. Kee may no longer work in the affected tab, if indeed the tab even exists any more. The exception that caused this is: "+l.message+" : "+l.stack),a.delete(o)}},this)},this)}getKeePassFileNameToOpen(){let e=u.current.keePassDBToOpen;return(e==""||this.isKeeVaultFileName(e))&&(e=u.current.keePassMRUDB),this.isKeeVaultFileName(e)?"":e}getVaultFileNameToOpen(){let e=u.current.keePassDBToOpen;return(e==""||!this.isKeeVaultFileName(e))&&(e=u.current.keePassMRUDB),this.isKeeVaultFileName(e)?e:""}isKeeVaultFileName(e){return!(e.indexOf("-")===-1||e.indexOf("/")>=0||e.indexOf("\\")>=0)}openKeePass(){const e=d.KeePassDatabases.some(s=>s.sessionType===m.Websocket),t=d.KeePassDatabases.some(s=>s.sessionType===m.Websocket&&s.sessionFeatures.indexOf("KPRPC_OPEN_AND_FOCUS_DATABASE")>=0);if(e&&!t){r.warn("Can't open KeePass because KeePassRPC version does not support KPRPC_OPEN_AND_FOCUS_DATABASE");return}this.selectDatabase(this.getKeePassFileNameToOpen(),!e,m.Websocket)}async loginToPasswordManager(){if(await this.selectAndFocusDatabase(this.getVaultFileNameToOpen(),this.getKeePassFileNameToOpen())!==m.Websocket){const t=await c.tabs.query({url:["https://keevault.pm/*","https://app-beta.kee.pm/*","https://app-dev.kee.pm/*"]});t&&t[0]?(c.tabs.update(t[0].id,{active:!0}),c.windows.update(t[0].windowId,{focused:!0})):c.tabs.create({url:"https://keevault.pm/",active:!0})}}recordEntrySaveResult(e,t){return t?(d.updateSaveEntryResult({result:e,receivedAt:new Date,fileName:t.database.fileName,uuid:t.uuid}),!0):(d.updateSaveEntryResult({result:"error",receivedAt:new Date}),!1)}getDatabaseName(e){return e==null&&(e=d.ActiveKeePassDatabaseIndex),d.KeePassDatabases.length>0&&d.KeePassDatabases[e]!=null&&d.KeePassDatabases[e].root!=null?d.KeePassDatabases[e].name:null}getDatabaseFileName(e){return e==null&&(e=d.ActiveKeePassDatabaseIndex),d.KeePassDatabases.length>0&&d.KeePassDatabases[e]!=null&&d.KeePassDatabases[e].root!=null?d.KeePassDatabases[e].fileName:null}selectDatabase(e,t,s){try{this.KeePassRPC.selectDB(e,t,s)}catch(n){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+n),n}}selectAndFocusDatabase(e,t){try{return this.KeePassRPC.selectAndFocusDatabase(e,t)}catch(s){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+s),s}}async addLogin(e,t,s,n){try{const o=await this.KeePassRPC.addLogin(e,t,s);this.recordEntrySaveResult("created",o)&&n()}catch(o){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+o),o}}async updateLogin(e,t,s,n){try{const o=await this.KeePassRPC.updateLogin(e,t,s);this.recordEntrySaveResult("updated",o)&&n()}catch(o){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+o),o}}getAllDatabases(){try{return this.KeePassRPC.getAllDatabases()}catch(e){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+e),e}}async findLogins(e,t,s,n,o,a){try{return this.KeePassRPC.findLogins(e,t,s,n,o,a)}catch(l){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+l),l}}launchLoginEditor(e,t){try{this.KeePassRPC.launchLoginEditor(e,t)}catch(s){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+s),s}}launchGroupEditor(e,t){try{this.KeePassRPC.launchGroupEditor(e,t)}catch(s){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+s),s}}async getPasswordProfiles(){try{return this.KeePassRPC.getPasswordProfiles()}catch(e){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+e),e}}async generatePassword(e,t){try{return this.KeePassRPC.generatePassword(e,t)}catch(s){throw r.error("Unexpected exception while connecting to KeePassRPC. Please inform the Kee team that they should be handling this exception: "+s),s}}KPRPCListener(e){const t=Date();r.debug("Signal received by KPRPCListener ("+e+") @"+t);let s=!1,n=!1;switch(e){case"0":r.warn("KeePassRPC is requesting authentication [deprecated].");break;case"3":r.info("KeePass' currently active DB is about to be opened.");break;case"4":r.info("KeePass' currently active DB has just been opened."),n=!0;break;case"5":r.info("KeePass' currently active DB is about to be closed.");break;case"6":r.info("KeePass' currently active DB has just been closed."),n=!0;break;case"7":r.info("KeePass' currently active DB is about to be saved.");break;case"8":r.info("KeePass' currently active DB has just been saved."),n=!0;break;case"9":r.info("KeePass' currently active DB is about to be deleted.");break;case"10":r.info("KeePass' currently active DB has just been deleted.");break;case"11":r.info("KeePass' active DB has been changed/selected."),n=!0;break;case"12":r.info("KeePass is shutting down. [deprecated: Now inferred from connection loss]");break;default:r.error("Invalid signal received by KPRPCListener ("+e+")");break}if(!n)return;const o=new Date().getTime();if(!window.kee.processingCallback&&window.kee.pendingCallback==""&&(r.debug("Signal executing now. @"+t),window.kee.processingCallback=!0,s=!0),n&&(s?(d.updateLastKeePassRPCRefresh(o),window.kee._refreshKPDB()):window.kee.pendingCallback="_refreshKPDB"),r.debug("Signal handled or queued. @"+t),s){try{window.kee.pendingCallback=="_refreshKPDB"?window.kee._refreshKPDB():r.debug("A pending signal was found and handled.")}finally{window.kee.pendingCallback="",window.kee.processingCallback=!1}r.debug("Signal handled. @"+t)}}RegularKPRPCListenerQueueHandler(){if(!(window.kee.processingCallback||window.kee.pendingCallback=="")){r.debug("RegularKPRPCListenerQueueHandler will execute the pending item now"),window.kee.processingCallback=!0;try{window.kee.pendingCallback=="_refreshKPDB"&&window.kee._refreshKPDB()}finally{window.kee.pendingCallback="",window.kee.processingCallback=!1}r.debug("RegularKPRPCListenerQueueHandler has finished executing the item")}}createTabStateIfMissing(e){window.kee.tabStates.has(e)||window.kee.tabStates.set(e,new me)}deleteTabState(e){window.kee.tabStates.delete(e)}initiatePasswordGeneration(){if(d.connected){const e=window.kee.tabStates.get(window.kee.foregroundTabId);if(e){const t=e.framePorts.get(0);if(t){t.postMessage({action:b.GeneratePassword});return}}window.kee.vaultPort&&(window.kee.vaultPort.postMessage({protocol:k.ShowGenerator}),c.tabs.update(window.kee.vaultPort.sender.tab.id,{active:!0}),c.windows.update(window.kee.vaultPort.sender.tab.windowId,{focused:!0}))}}}const B=60*15,Pe=60*60*8;c.browserAction.setBadgeText({text:"OFF"});c.browserAction.setBadgeBackgroundColor({color:"red"});c.browserAction.disable();const ve=Y(ee);ve.use(z());const Ce=E();async function Te(){r.attachConfig(u.current),await Ae(),window.kee=new ye,window.kee.init(),u.addChangeListener(()=>window.kee.configSyncManager.updateToRemoteConfig(u.current)),c.browserAction.enable()}async function Ae(){if(u.current.mustShowReleaseNotesAtStartup){const i=await c.tabs.create({url:"release-notes/update-notes.html",active:!0});c.windows.update(i.windowId,{focused:!0,drawAttention:!0}),u.setASAP({mustShowReleaseNotesAtStartup:!1})}}c.windows.onFocusChanged.addListener(async function(i){if(r&&r.debug&&r.debug("Focus changed for id: "+i),i!==c.windows.WINDOW_ID_NONE){const e=await c.tabs.query({active:!0,windowId:i});e[0]&&e[0].id!=null&&W(e[0].id)}});c.tabs.onActivated.addListener(i=>{r&&r.debug&&r.debug("Tab activated with id: "+i.tabId),W(i.tabId)});function W(i){Re(i),window.kee&&M.setupContextMenuItems()}function Re(i){window.kee&&window.kee.foregroundTabId!==i&&(window.kee.foregroundTabId=i,window.kee.tabStates.has(i)&&window.kee.tabStates.get(i).framePorts&&(r&&r.debug&&r.debug("kee activated on tab: "+i),window.kee.tabStates.get(i).framePorts.forEach(e=>{e.postMessage({isForegroundTab:!0,action:b.DetectForms,resetState:Ce.$state})})))}__KeeIsRunningInAWebExtensionsBrowser||c.runtime.onInstalled.addListener(()=>{const i=()=>{c.runtime.lastError&&(r&&r.error?r.error(c.runtime.lastError.message):console.error(c.runtime.lastError))};c.runtime.getManifest().content_scripts.forEach(e=>{const t=e.all_frames,s=e.matches,n=["https://app-dev.kee.pm:8087/","https://app-beta.kee.pm/","https://app.kee.pm/","https://keevault.pm/"],o=a=>{a.url&&a.url.startsWith("chrome://")||e.exclude_globs&&e.exclude_globs.length>0&&n.some(l=>a.url.startsWith(l))||e.include_globs&&e.include_globs.length>0&&!n.some(l=>a.url.startsWith(l))||((e.js||[]).forEach(l=>{c.tabs.executeScript(a.id,{allFrames:t,file:l}).then(i)}),(e.css||[]).forEach(l=>{c.tabs.insertCSS(a.id,{allFrames:t,file:l}).then(i)}))};c.tabs.query({url:s}).then(a=>a.forEach(o))})});c.runtime.onInstalled.addListener(async function(i){if(i.reason==="install"){const e=await c.tabs.query({url:["https://keevault.pm/*","https://app-beta.kee.pm/*","https://app-dev.kee.pm/*"]});e&&e[0]?(c.tabs.update(e[0].id,{active:!0}),c.windows.update(e[0].windowId,{focused:!0})):c.tabs.create({url:"release-notes/install-notes.html"})}});c.runtime.onUpdateAvailable.addListener(async()=>{await u.setASAP({mustShowReleaseNotesAtStartup:!0}),await c.idle.queryState(B)==="idle"?c.runtime.reload():(c.idle.setDetectionInterval(B),c.idle.onStateChanged.addListener(i=>{i!=="active"&&c.runtime.reload()}),window.setTimeout(()=>{c.runtime.reload()},Pe*1e3))});u.load(Te);
